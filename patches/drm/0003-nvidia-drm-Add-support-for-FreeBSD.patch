From 670aaa88956dcb36fe9de928120dd43e6589b096 Mon Sep 17 00:00:00 2001
From: Austin Shafer <ashafer@nvidia.com>
Date: Sun, 13 Feb 2022 20:27:07 -0500
Subject: [PATCH 3/3] nvidia-drm: Add support for FreeBSD

This is the actual source changes needed to make FreeBSD work. All
FreeBSD subsystem specific parts are in nvidia-drm-freebsd-lkpi.c

Fixes:
- Use stdint NvU64, use proper printf qualifiers for it
- Define vm_flags_t for nv-mm.h
- Add a FreeBSD linuxkpi file handling FreeBSD module setup
- Add FreeBSD's linuxkpi module declarations
- Use FreeBSD virtual memory functions in GEM memory handling
---
diff --git a/nvidia/src/nvidia-drm/nv-pci-table.c b/nvidia/src/nvidia-drm/nv-pci-table.c
index e3494735a5f..a7f82945147 100644
--- a/nvidia/src/nvidia-drm/nv-pci-table.c
+++ b/nvidia/src/nvidia-drm/nv-pci-table.c
@@ -25,6 +25,7 @@
 #include <linux/module.h>
 
 #include "nv-pci-table.h"
+#include "nvtypes.h"
 
 /* Devices supported by RM */
 struct pci_device_id nv_pci_table[] = {
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-conftest.h b/nvidia/src/nvidia-drm/nvidia-drm-conftest.h
index fd389f1099d..7d6f5ca79cf 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-conftest.h
+++ b/nvidia/src/nvidia-drm/nvidia-drm-conftest.h
@@ -24,6 +24,7 @@
 #define __NVIDIA_DRM_CONFTEST_H__
 
 #include "conftest.h"
+#include "nvtypes.h"
 
 /*
  * NOTE: This file is expected to get included at the top before including any
@@ -72,4 +73,50 @@
 #undef NV_DRM_COLOR_MGMT_AVAILABLE
 #endif
 
+/*
+ * Now for the FreeBSD specific stuff. These fix some quirks with FreeBSD's
+ * Linux kernel compatibility layer.
+ */
+#if defined(NV_BSD)
+
+#include <linux/rwsem.h>
+#include <sys/param.h>
+#include <sys/lock.h>
+#include <sys/sx.h>
+
+/* For nv_drm_gem_prime_force_fence_signal */
+#ifndef spin_is_locked
+#define spin_is_locked(lock) mtx_owned(lock.m)
+#endif
+
+#ifndef rwsem_is_locked
+#define rwsem_is_locked(sem) (((sem)->sx.sx_lock & (SX_LOCK_SHARED)) \
+                              || ((sem)->sx.sx_lock & ~(SX_LOCK_FLAGMASK & ~SX_LOCK_SHARED)))
+#endif
+
+/*
+ * FreeBSD does not define vm_flags_t in its linuxkpi, since there is already
+ * a FreeBSD vm_flags_t (of a different size) and they don't want the names to
+ * collide. Do some surgery on nv-mm.h here.
+ */
+#define vm_flags_t unsigned long
+#include "nv-mm.h"
+#undef vm_flags_t
+
+/*
+ * sys/nv.h and nvidia/nv.h have the same header guard
+ * we need to clear it for nvlist_t  to get loaded
+ */
+#undef _NV_H_
+#include <sys/nv.h>
+
+/*
+ * For now just use set_page_dirty as the lock variant
+ * is not ported for FreeBSD. (in progress). This calls
+ * vm_page_dirty. Used in nv-mm.h
+ */
+#define set_page_dirty_lock set_page_dirty
+
+#endif /* defined(NV_BSD) */
+
 #endif /* defined(__NVIDIA_DRM_CONFTEST_H__) */
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-drv.c b/nvidia/src/nvidia-drm/nvidia-drm-drv.c
index 3b6f2bf9128..250429955a8 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-drv.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-drv.c
@@ -1640,7 +1640,7 @@ static struct drm_driver nv_drm_driver = {
  * kernel supports atomic modeset and the 'modeset' kernel module
  * parameter is true.
  */
-static void nv_drm_update_drm_driver_features(void)
+void nv_drm_update_drm_driver_features(void)
 {
 #if defined(NV_DRM_ATOMIC_MODESET_AVAILABLE)
 
@@ -1666,7 +1666,7 @@ static void nv_drm_update_drm_driver_features(void)
 /*
  * Helper function for allocate/register DRM device for given NVIDIA GPU ID.
  */
-static void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
+void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
 {
     struct nv_drm_device *nv_dev = NULL;
     struct drm_device *dev = NULL;
@@ -1704,8 +1704,17 @@ static void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
     dev->dev_private = nv_dev;
     nv_dev->dev = dev;
 
+    bool bus_is_pci =
+#if defined(NV_LINUX)
+    device->bus == &pci_bus_type;
+#elif defined(NV_BSD)
+    devclass_find("pci");
+#else
+    false;
+#endif
+
 #if defined(NV_DRM_DEVICE_HAS_PDEV)
-    if (device->bus == &pci_bus_type) {
+    if (bus_is_pci) {
         dev->pdev = to_pci_dev(device);
     }
 #endif
@@ -1726,7 +1735,7 @@ static void nv_drm_register_drm_device(const nv_gpu_info_t *gpu_info)
             goto failed_grab_ownership;
         }
 
-        if (device->bus == &pci_bus_type) {
+        if (bus_is_pci) {
             struct pci_dev *pdev = to_pci_dev(device);
 
 #if defined(NV_DRM_APERTURE_REMOVE_CONFLICTING_PCI_FRAMEBUFFERS_HAS_DRIVER_ARG)
@@ -1766,6 +1775,7 @@ failed_drm_alloc:
 /*
  * Enumerate NVIDIA GPUs and allocate/register DRM device for each of them.
  */
+#if defined(NV_LINUX)
 int nv_drm_probe_devices(void)
 {
     nv_gpu_info_t *gpu_info = NULL;
@@ -1808,6 +1818,7 @@ done:
 
     return ret;
 }
+#endif
 
 /*
  * Unregister all NVIDIA DRM devices.
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-fb.c b/nvidia/src/nvidia-drm/nvidia-drm-fb.c
index 2747123ff5f..1c84201552a 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-fb.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-fb.c
@@ -240,7 +240,7 @@ struct drm_framebuffer *nv_drm_internal_framebuffer_create(
         if (nv_dev->modifiers[i] == DRM_FORMAT_MOD_INVALID) {
             NV_DRM_DEV_DEBUG_DRIVER(
                 nv_dev,
-                "Invalid format modifier for framebuffer object: 0x%016llx",
+                "Invalid format modifier for framebuffer object: 0x%016" NvU64_fmtx,
                 modifier);
             return ERR_PTR(-EINVAL);
         }
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-fence.c b/nvidia/src/nvidia-drm/nvidia-drm-fence.c
index 23298ad12cc..e6621178f4f 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-fence.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-fence.c
@@ -1638,7 +1638,7 @@ int nv_drm_semsurf_fence_wait_ioctl(struct drm_device *dev,
     if (p->pre_wait_value >= p->post_wait_value) {
         NV_DRM_DEV_LOG_ERR(
             nv_dev,
-            "Non-monotonic wait values specified to fence wait: 0x%llu, 0x%llu",
+            "Non-monotonic wait values specified to fence wait: 0x%" NvU64_fmtu ", 0x%" NvU64_fmtu,
             p->pre_wait_value, p->post_wait_value);
         goto done;
     }
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-freebsd-lkpi.c b/nvidia/src/nvidia-drm/nvidia-drm-freebsd-lkpi.c
new file mode 100644
index 00000000000..f2339af0ace
--- /dev/null
+++ b/nvidia/src/nvidia-drm/nvidia-drm-freebsd-lkpi.c
@@ -0,0 +1,417 @@
+/*
+ * Copyright (c) 2015, NVIDIA CORPORATION. All rights reserved.
+ *
+ * Permission is hereby granted, free of charge, to any person obtaining a
+ * copy of this software and associated documentation files (the "Software"),
+ * to deal in the Software without restriction, including without limitation
+ * the rights to use, copy, modify, merge, publish, distribute, sublicense,
+ * and/or sell copies of the Software, and to permit persons to whom the
+ * Software is furnished to do so, subject to the following conditions:
+ *
+ * The above copyright notice and this permission notice shall be included in
+ * all copies or substantial portions of the Software.
+ *
+ * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
+ * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
+ * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT.  IN NO EVENT SHALL
+ * THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
+ * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
+ * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
+ * DEALINGS IN THE SOFTWARE.
+ */
+
+/*
+ * include the FreeBSD structures (nvidia_softc)
+ * have to grab it from src/nvidia/nv-freebsd.h
+ *
+ * have to be done first before the LIST_HEAD linux version
+ */
+#include "nvmisc.h"
+#define NVRM
+#include "../nvidia/nv.h"
+#include "../nvidia/nv-freebsd.h"
+
+/* undef BIT, since it was just identically defined in nvmisc.h */
+#undef BIT
+#include <linux/module.h>
+#include <linux/slab.h>
+#include <linux/err.h>
+
+#include "../nvidia/os-interface.h"
+
+#include "nvidia-drm-os-interface.h"
+#include "nvidia-drm.h"
+
+#include "nvidia-drm-conftest.h"
+
+#if defined(NV_LINUX_SYNC_FILE_H_PRESENT)
+#include <linux/file.h>
+#include <linux/sync_file.h>
+#endif
+
+#if defined(NV_DRM_AVAILABLE)
+
+#include "nv-mm.h"
+
+#include "nv-gpu-info.h"
+#include "nvidia-drm-drv.h"
+#include "nvidia-drm-priv.h"
+
+#include <linux/device.h>
+#include <linux/vmalloc.h>
+
+/* Define PCI classes that FreeBSD's linuxkpi is missing */
+#define PCI_VENDOR_ID_NVIDIA 0x10de
+#define PCI_CLASS_DISPLAY_VGA 0x0300
+#define PCI_CLASS_DISPLAY_3D 0x0302
+#define PCI_CLASS_BRIDGE_OTHER 0x0680
+
+/* Devices supported by RM */
+struct pci_device_id nv_pci_table[] = {
+    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_DISPLAY_VGA << 8),
+        .class_mask  = ~0
+    },
+    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_DISPLAY_3D << 8),
+        .class_mask  = ~0
+    },
+    { }
+};
+
+/* Devices supported by all drivers in nvidia.ko */
+struct pci_device_id nv_module_device_table[] = {
+    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_DISPLAY_VGA << 8),
+        .class_mask  = ~0
+    },
+    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_DISPLAY_3D << 8),
+        .class_mask  = ~0
+    },
+    {
+        .vendor      = PCI_VENDOR_ID_NVIDIA,
+        .device      = PCI_ANY_ID,
+        .subvendor   = PCI_ANY_ID,
+        .subdevice   = PCI_ANY_ID,
+        .class       = (PCI_CLASS_BRIDGE_OTHER << 8),
+        .class_mask  = ~0
+    },
+    { }
+};
+
+bool nv_drm_modeset_module_param = true;
+bool nv_drm_fbdev_module_param = false;
+
+SYSCTL_NODE(_hw, OID_AUTO, nvidiadrm, CTLFLAG_RD | CTLFLAG_MPSAFE, 0,
+    "nvidia-drm kernel module parameters");
+SYSCTL_BOOL(_hw_nvidiadrm, OID_AUTO, modeset,  CTLFLAG_RD | CTLFLAG_MPSAFE,
+    &nv_drm_modeset_module_param,  1,
+    "Enable atomic kernel modesetting (1 = enable, 0 = disable (default))");
+SYSCTL_BOOL(_hw_nvidiadrm, OID_AUTO, fbdev,  CTLFLAG_RD | CTLFLAG_MPSAFE,
+    &nv_drm_fbdev_module_param,  0,
+    "Enable atomic kernel modesetting (1 = enable, 0 = disable (default))");
+
+void *nv_drm_calloc(size_t nmemb, size_t size)
+{
+    return kzalloc(nmemb * size, GFP_KERNEL);
+}
+
+void nv_drm_free(void *ptr)
+{
+    if (IS_ERR(ptr)) {
+        return;
+    }
+
+    kfree(ptr);
+}
+
+char *nv_drm_asprintf(const char *fmt, ...)
+{
+    va_list ap;
+    char *p;
+
+    va_start(ap, fmt);
+    p = kvasprintf(GFP_KERNEL, fmt, ap);
+    va_end(ap);
+
+    return p;
+}
+
+#if defined(NVCPU_X86) || defined(NVCPU_X86_64)
+  #define WRITE_COMBINE_FLUSH()    sfence()
+#elif defined(NVCPU_FAMILY_ARM)
+  #if defined(NVCPU_ARM)
+    #define WRITE_COMBINE_FLUSH()  { dsb(); outer_sync(); }
+  #elif defined(NVCPU_AARCH64)
+    #define WRITE_COMBINE_FLUSH()  mb()
+  #endif
+#elif defined(NVCPU_PPC64LE)
+  /* should include powerpc_sync for a cleaner approach */
+  #define WRITE_COMBINE_FLUSH()    __asm __volatile("sync":::"memory")
+#endif
+
+void nv_drm_write_combine_flush(void)
+{
+    WRITE_COMBINE_FLUSH();
+}
+
+int nv_drm_lock_user_pages(unsigned long address,
+                           unsigned long pages_count, struct page ***pages)
+{
+    struct mm_struct *mm = current->mm;
+    struct page **user_pages;
+    const int write = 1;
+    int pages_pinned;
+
+    user_pages = nv_drm_calloc(pages_count, sizeof(*user_pages));
+
+    if (user_pages == NULL) {
+        return -ENOMEM;
+    }
+
+    down_read(&mm->mmap_sem);
+
+    pages_pinned = NV_GET_USER_PAGES(address, pages_count, write,
+                                     user_pages);
+    up_read(&mm->mmap_sem);
+
+    if (pages_pinned < 0 || (unsigned)pages_pinned < pages_count) {
+        goto failed;
+    }
+
+    *pages = user_pages;
+
+    return 0;
+
+failed:
+
+    if (pages_pinned > 0) {
+        int i;
+
+        for (i = 0; i < pages_pinned; i++) {
+            put_page(user_pages[i]);
+        }
+    }
+
+    nv_drm_free(user_pages);
+
+    return (pages_pinned < 0) ? pages_pinned : -EINVAL;
+}
+
+void nv_drm_unlock_user_pages(unsigned long  pages_count, struct page **pages)
+{
+    unsigned long i;
+
+    for (i = 0; i < pages_count; i++) {
+        set_page_dirty_lock(pages[i]);
+
+        put_page(pages[i]);
+    }
+
+    nv_drm_free(pages);
+}
+
+/*
+ * linuxkpi vmap doesn't use the flags argument as it
+ * doesn't seem to be needed. Define VM_USERMAP to 0
+ * to make errors go away
+ *
+ * vmap: sys/compat/linuxkpi/common/src/linux_compat.c
+ */
+#define VM_USERMAP 0
+
+void *nv_drm_vmap(struct page **pages, unsigned long pages_count)
+{
+    return vmap(pages, pages_count, VM_USERMAP, PAGE_KERNEL);
+}
+
+void nv_drm_vunmap(void *address)
+{
+    vunmap(address);
+}
+
+/*************************************************************************
+ * FreeBSD linuxkpi based loading support code.
+ *************************************************************************/
+
+struct pci_dev *nv_lkpi_pci_devs[NV_MAX_DEVICES];
+
+int nv_drm_probe_devices(void)
+{
+    nv_drm_update_drm_driver_features();
+
+    /*
+     * Conveniently we can get all of the nvidia devices that were initialized
+     * by the native nvidia.ko by using our devclass.
+     */
+    for (int i = 0; i < NV_MAX_DEVICES; i++) {
+        nv_gpu_info_t gpu_info;
+        struct nvidia_softc *sc = devclass_get_softc(nvidia_devclass, i);
+        if (!sc) {
+            nv_lkpi_pci_devs[i] = NULL;
+            continue;
+        }
+        nv_state_t *nv = sc->nv_state;
+
+        /*
+         * Now we have the state (which gives us the device_t), but what nvidia-drm
+         * wants is a pci_dev suitable for use with linuxkpi code. We can use
+         * lkpinew_pci_dev to fill in a pci_dev struct,
+         */
+        struct pci_dev *pdev = lkpinew_pci_dev(sc->dev);
+        nv_lkpi_pci_devs[i] = pdev;
+
+        gpu_info.gpu_id = nv->gpu_id;
+
+        gpu_info.pci_info.domain   = nv->pci_info.domain;
+        gpu_info.pci_info.bus      = nv->pci_info.bus;
+        gpu_info.pci_info.slot     = nv->pci_info.slot;
+        gpu_info.pci_info.function = nv->pci_info.function;
+        gpu_info.os_device_ptr = pdev;
+
+        nv_drm_register_drm_device(&gpu_info);
+    }
+
+    return 0;
+}
+
+bool nv_drm_workthread_init(nv_drm_workthread *worker, const char *name)
+{
+    worker->shutting_down = false;
+    if (nv_kthread_q_init(&worker->q, name)) {
+        return false;
+    }
+
+    spin_lock_init(&worker->lock);
+
+    return true;
+}
+
+void nv_drm_workthread_shutdown(nv_drm_workthread *worker)
+{
+    unsigned long flags;
+
+    spin_lock_irqsave(&worker->lock, flags);
+    worker->shutting_down = true;
+    spin_unlock_irqrestore(&worker->lock, flags);
+
+    nv_kthread_q_stop(&worker->q);
+}
+
+void nv_drm_workthread_work_init(nv_drm_work *work,
+                                 void (*callback)(void *),
+                                 void *arg)
+{
+    nv_kthread_q_item_init(work, callback, arg);
+}
+
+int nv_drm_workthread_add_work(nv_drm_workthread *worker, nv_drm_work *work)
+{
+    unsigned long flags;
+    int ret = 0;
+
+    spin_lock_irqsave(&worker->lock, flags);
+    if (!worker->shutting_down) {
+        ret = nv_kthread_q_schedule_q_item(&worker->q, work);
+    }
+    spin_unlock_irqrestore(&worker->lock, flags);
+
+    return ret;
+}
+
+void nv_drm_timer_setup(nv_drm_timer *timer, void (*callback)(nv_drm_timer *nv_drm_timer))
+{
+    nv_timer_setup(timer, callback);
+}
+
+void nv_drm_mod_timer(nv_drm_timer *timer, unsigned long timeout_native)
+{
+    mod_timer(&timer->kernel_timer, timeout_native);
+}
+
+unsigned long nv_drm_timer_now(void)
+{
+    return jiffies;
+}
+
+unsigned long nv_drm_timeout_from_ms(NvU64 relative_timeout_ms)
+{
+    return jiffies + msecs_to_jiffies(relative_timeout_ms);
+}
+
+bool nv_drm_del_timer_sync(nv_drm_timer *timer)
+{
+    if (del_timer_sync(&timer->kernel_timer)) {
+        return true;
+    } else {
+        return false;
+    }
+}
+
+int nv_drm_create_sync_file(nv_dma_fence_t *fence)
+{
+#if defined(NV_LINUX_SYNC_FILE_H_PRESENT)
+    struct sync_file *sync;
+    int fd = get_unused_fd_flags(O_CLOEXEC);
+
+    if (fd < 0) {
+        return fd;
+    }
+
+    /* sync_file_create() generates its own reference to the fence */
+    sync = sync_file_create(fence);
+
+    if (IS_ERR(sync)) {
+        put_unused_fd(fd);
+        return PTR_ERR(sync);
+    }
+
+    fd_install(fd, sync->file);
+
+    return fd;
+#else /* defined(NV_LINUX_SYNC_FILE_H_PRESENT) */
+    return -EINVAL;
+#endif  /* defined(NV_LINUX_SYNC_FILE_H_PRESENT) */
+}
+
+nv_dma_fence_t *nv_drm_sync_file_get_fence(int fd)
+{
+#if defined(NV_SYNC_FILE_GET_FENCE_PRESENT)
+    return sync_file_get_fence(fd);
+#else /* defined(NV_SYNC_FILE_GET_FENCE_PRESENT) */
+    return NULL;
+#endif  /* defined(NV_SYNC_FILE_GET_FENCE_PRESENT) */
+}
+
+void nv_drm_yield(void)
+{
+    set_current_state(TASK_INTERRUPTIBLE);
+    schedule_timeout(1);
+}
+
+LKPI_DRIVER_MODULE(nvidia_drm, nv_drm_init, nv_drm_exit);
+LKPI_PNP_INFO(pci, nvidia_drm, nv_module_device_table);
+MODULE_DEPEND(nvidia_drm, linuxkpi, 1, 1, 1);
+MODULE_DEPEND(nvidia_drm, linuxkpi_gplv2, 1, 1, 1);
+MODULE_DEPEND(nvidia_drm, drmn, 2, 2, 2);
+MODULE_DEPEND(nvidia_drm, dmabuf, 1, 1, 1);
+MODULE_DEPEND(nvidia_drm, nvidia, 1, 1, 1);
+MODULE_DEPEND(nvidia_drm, nvidia_modeset, 1, 1, 1);
+#endif /* NV_DRM_AVAILABLE */
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-gem-dma-buf.c b/nvidia/src/nvidia-drm/nvidia-drm-gem-dma-buf.c
index fccde05d010..14cab7d9484 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-gem-dma-buf.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-gem-dma-buf.c
@@ -71,12 +71,43 @@ static int __nv_drm_gem_dma_buf_create_mmap_offset(
 static int __nv_drm_gem_dma_buf_mmap(struct nv_drm_gem_object *nv_gem,
                                      struct vm_area_struct *vma)
 {
+#if defined(NV_LINUX)
     struct dma_buf_attachment *attach = nv_gem->base.import_attach;
     struct dma_buf *dma_buf = attach->dmabuf;
+#endif
     struct file *old_file;
     int ret;
 
     /* check if buffer supports mmap */
+#if defined(NV_BSD)
+    /*
+     * Most of the bsd drm bits refer to struct file*, which is actually
+     * a struct linux_file*. The dmabuf bits in bsd are not actually plumbed
+     * through the same linuxkpi bits it seems (probably so it can be used
+     * elsewhere), so dma_buf->file really is a native freebsd struct file...
+     *
+     * This is just different enough to be annoying
+     */
+    if (!nv_gem->base.filp->f_op->mmap)
+        return -EINVAL;
+
+    /* readjust the vma */
+    get_file(nv_gem->base.filp);
+    old_file = vma->vm_file;
+    vma->vm_file = nv_gem->base.filp;
+    vma->vm_pgoff -= drm_vma_node_start(&nv_gem->base.vma_node);;
+
+    ret = nv_gem->base.filp->f_op->mmap(nv_gem->base.filp, vma);
+
+    if (ret) {
+        /* restore old parameters on failure */
+        vma->vm_file = old_file;
+        fput(nv_gem->base.filp);
+    } else {
+        if (old_file)
+            fput(old_file);
+    }
+#else
     if (!dma_buf->file->f_op->mmap)
         return -EINVAL;
 
@@ -96,6 +127,7 @@ static int __nv_drm_gem_dma_buf_mmap(struct nv_drm_gem_object *nv_gem,
         if (old_file)
             fput(old_file);
     }
+#endif
 
     return ret;
 }
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-gem-nvkms-memory.c b/nvidia/src/nvidia-drm/nvidia-drm-gem-nvkms-memory.c
index 7d66c432ec0..6a6dd4e6178 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-gem-nvkms-memory.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-gem-nvkms-memory.c
@@ -37,6 +37,9 @@
 #endif
 
 #include <linux/io.h>
+#if defined(NV_BSD)
+#include <vm/vm_pageout.h>
+#endif
 
 #include "nv-mm.h"
 
@@ -93,12 +96,24 @@ static vm_fault_t __nv_drm_gem_nvkms_handle_vma_fault(
     if (nv_nvkms_memory->pages_count == 0) {
         pfn = (unsigned long)(uintptr_t)nv_nvkms_memory->pPhysicalAddress;
         pfn >>= PAGE_SHIFT;
+#if defined(NV_LINUX)
+        /*
+         * FreeBSD doesn't set pgoff. We instead have pfn be the base physical
+         * address, and we will calculate the index pidx from the virtual address.
+         *
+         * This only works because linux_cdev_pager_populate passes the pidx as
+         * vmf->virtual_address, which is stupid. Then we turn the virtual address
+         * into a physical page number, which is also stupid. The stupid cancels
+         * out and everything works.
+         */
         pfn += page_offset;
+#endif
     } else {
         BUG_ON(page_offset >= nv_nvkms_memory->pages_count);
         pfn = page_to_pfn(nv_nvkms_memory->pages[page_offset]);
     }
 
+#if defined(NV_LINUX)
 #if defined(NV_VMF_INSERT_PFN_PRESENT)
     ret = vmf_insert_pfn(vma, address, pfn);
 #else
@@ -121,7 +136,57 @@ static vm_fault_t __nv_drm_gem_nvkms_handle_vma_fault(
             break;
     }
 #endif /* defined(NV_VMF_INSERT_PFN_PRESENT) */
+#else
+    /* FreeBSD specific: find location to insert new page */
+    vm_pindex_t pidx = OFF_TO_IDX(address);
+    vm_object_t obj = vma->vm_obj;
+    vm_page_t page;
+
+    VM_OBJECT_WLOCK(obj);
+    for (;;) {
+        /*
+         * First we try to grab our page within the obj, getting it if it exists
+         * but don't allocate it if it doesn't.
+         */
+        page = vm_page_grab(obj, pidx, VM_ALLOC_NOCREAT);
+        if (!page) {
+            /* Now we create the page */
+            page = PHYS_TO_VM_PAGE(IDX_TO_OFF(pfn + pidx));
+            if (!page) {
+                VM_OBJECT_WUNLOCK(obj);
+                return VM_FAULT_SIGBUS;
+            }
+            /* try to busy it, if not restart this process */
+            if (!vm_page_busy_acquire(page, VM_ALLOC_WAITFAIL)) {
+                continue;
+            }
+            /* now we can insert the page in our object */
+            if (vm_page_insert(page, obj, pidx)) {
+                vm_page_xunbusy(page);
+                VM_OBJECT_WUNLOCK(obj);
+				vm_wait(NULL);
+				VM_OBJECT_WLOCK(obj);
+                continue;
+            }
+            vm_page_valid(page);
+        }
+        break;
+    }
+    VM_OBJECT_WUNLOCK(obj);
+
+    ret = VM_FAULT_NOPAGE;
+
+    /*
+     * linuxkpi will communicate to vm_fault_populate which pages to
+     * map into the address space based on vm_pfn_first and vm_pfn_count
+     *  (sys/compat/linuxkpi/common/src/linux_compat.c line 577)
+     * we only mapped one page at a time, the page we added was page pidx
+     */
+    vma->vm_pfn_first = pidx;
+    vma->vm_pfn_count = 1;
     return ret;
+#endif /* __linux__ */
+        return ret;
 #endif /* defined(NV_DRM_ATOMIC_MODESET_AVAILABLE) */
     return VM_FAULT_SIGBUS;
 }
@@ -314,7 +379,7 @@ int nv_drm_dumb_create(
         ret = -ENOMEM;
         NV_DRM_DEV_LOG_ERR(
             nv_dev,
-            "Failed to allocate NvKmsKapiMemory for dumb object of size %llu",
+            "Failed to allocate NvKmsKapiMemory for dumb object of size %" NvU64_fmtu,
             args->size);
         goto nvkms_alloc_memory_failed;
     }
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-gem-user-memory.c b/nvidia/src/nvidia-drm/nvidia-drm-gem-user-memory.c
index 93824098794..fde6bb137ef 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-gem-user-memory.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-gem-user-memory.c
@@ -35,6 +35,7 @@
 #include "linux/dma-buf.h"
 #include "linux/mm.h"
 #include "nv-mm.h"
+#include <vm/vm_pageout.h>
 
 static inline
 void __nv_drm_gem_user_memory_free(struct nv_drm_gem_object *nv_gem)
@@ -113,6 +114,67 @@ static vm_fault_t __nv_drm_gem_user_memory_handle_vma_fault(
     page_offset = vmf->pgoff - drm_vma_node_start(&gem->vma_node);
 
     BUG_ON(page_offset >= nv_user_memory->pages_count);
+
+#ifndef __linux__
+    /*
+     * FreeBSD specific: find location to insert new page
+     *
+     * FreeBSD doesn't set pgoff. We instead have pfn be the base physical
+     * address, and we will calculate the index pidx from the virtual address.
+     *
+     * This only works because linux_cdev_pager_populate passes the pidx as
+     * vmf->virtual_address, which is stupid. Then we turn the virtual address
+     * into a physical page number, which is also stupid. The stupid cancels
+     * out and everything works.
+     */
+    unsigned long pfn = page_to_pfn(nv_user_memory->pages[page_offset]);
+    vm_pindex_t pidx = OFF_TO_IDX(address);
+    vm_object_t obj = vma->vm_obj;
+    vm_page_t page;
+
+    VM_OBJECT_WLOCK(obj);
+    for (;;) {
+        /*
+         * First we try to grab our page within the obj, getting it if it exists
+         * but don't allocate it if it doesn't.
+         */
+        page = vm_page_grab(obj, pidx, VM_ALLOC_NOCREAT);
+        if (!page) {
+            /* Now we create the page */
+            page = PHYS_TO_VM_PAGE(IDX_TO_OFF(pfn + pidx));
+            if (!page) {
+                VM_OBJECT_WUNLOCK(obj);
+                return VM_FAULT_SIGBUS;
+            }
+            /* try to busy it, if not restart this process */
+            if (!vm_page_busy_acquire(page, VM_ALLOC_WAITFAIL)) {
+                continue;
+            }
+            /* now we can insert the page in our object */
+            if (vm_page_insert(page, obj, pidx)) {
+                vm_page_xunbusy(page);
+                VM_OBJECT_WUNLOCK(obj);
+				vm_wait(NULL);
+				VM_OBJECT_WLOCK(obj);
+                continue;
+            }
+            vm_page_valid(page);
+        }
+        break;
+    }
+    VM_OBJECT_WUNLOCK(obj);
+
+    ret = VM_FAULT_NOPAGE;
+
+    /*
+     * linuxkpi will communicate to vm_fault_populate which pages to
+     * map into the address space based on vm_pfn_first and vm_pfn_count
+     *  (sys/compat/linuxkpi/common/src/linux_compat.c line 577)
+     * we only mapped one page at a time, the page we added was page pidx
+     */
+    vma->vm_pfn_first = pidx;
+    vma->vm_pfn_count = 1;
+#else /* !defined(__linux__) */
     ret = vm_insert_page(vma, address, nv_user_memory->pages[page_offset]);
     switch (ret) {
         case 0:
@@ -131,6 +193,7 @@ static vm_fault_t __nv_drm_gem_user_memory_handle_vma_fault(
             ret = VM_FAULT_SIGBUS;
             break;
     }
+#endif /* !defined(__linux__) */
 
     return ret;
 }
@@ -170,7 +233,7 @@ int nv_drm_gem_import_userspace_memory_ioctl(struct drm_device *dev,
     if ((params->size % PAGE_SIZE) != 0) {
         NV_DRM_DEV_LOG_ERR(
             nv_dev,
-            "Userspace memory 0x%llx size should be in a multiple of page "
+            "Userspace memory 0x%" NvU64_fmtx " size should be in a multiple of page "
             "size to create a gem object",
             params->address);
         return -EINVAL;
@@ -183,7 +246,7 @@ int nv_drm_gem_import_userspace_memory_ioctl(struct drm_device *dev,
     if (ret != 0) {
         NV_DRM_DEV_LOG_ERR(
             nv_dev,
-            "Failed to lock user pages for address 0x%llx: %d",
+            "Failed to lock user pages for address 0x%" NvU64_fmtx ": %d",
             params->address, ret);
         return ret;
     }
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-helper.c b/nvidia/src/nvidia-drm/nvidia-drm-helper.c
index dd6f89a7cd7..4fead376b1e 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-helper.c
+++ b/nvidia/src/nvidia-drm/nvidia-drm-helper.c
@@ -200,7 +200,11 @@ free:
     drm_atomic_state_put(state);
 #else
     if (ret != 0) {
+#ifdef __linux__
         drm_atomic_state_free(state);
+#else
+        drm_atomic_state_put(state);
+#endif
     } else {
         /*
          * In case of success, drm_atomic_commit() takes care to cleanup and
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-drv.h b/nvidia/src/nvidia-drm/nvidia-drm-drv.h
index cd20ec93fe3..20539850a11 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-drv.h
+++ b/nvidia/src/nvidia-drm/nvidia-drm-drv.h
@@ -31,6 +31,10 @@ int nv_drm_probe_devices(void);
 
 void nv_drm_remove_devices(void);
 
+void nv_drm_register_drm_device(const nv_gpu_info_t *);
+
+void nv_drm_update_drm_driver_features(void);
+
 #endif /* defined(NV_DRM_AVAILABLE) */
 
 #endif /* __NVIDIA_DRM_DRV_H__ */
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-os-interface.h b/nvidia/src/nvidia-drm/nvidia-drm-os-interface.h
index 51c7a7fda32..44299665bea 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-os-interface.h
+++ b/nvidia/src/nvidia-drm/nvidia-drm-os-interface.h
@@ -33,7 +33,7 @@
 #include "nvidia-dma-fence-helper.h"
 #endif
 
-#if defined(NV_LINUX)
+#if defined(NV_LINUX) || defined(NV_BSD)
 #include "nv-kthread-q.h"
 #include "linux/spinlock.h"
 
@@ -49,7 +49,7 @@ typedef nv_kthread_q_item_t nv_drm_work;
 #error "Need to define deferred work primitives for this OS"
 #endif /* else defined(NV_LINUX) */
 
-#if defined(NV_LINUX)
+#if defined(NV_LINUX) || defined(NV_BSD)
 #include "nv-timer.h"
 
 typedef struct nv_timer nv_drm_timer;
diff --git a/nvidia/src/nvidia-drm/nvidia-drm-ioctl.h b/nvidia/src/nvidia-drm/nvidia-drm-ioctl.h
index d1e7a078035..62f3209ac3e 100644
--- a/nvidia/src/nvidia-drm/nvidia-drm-ioctl.h
+++ b/nvidia/src/nvidia-drm/nvidia-drm-ioctl.h
@@ -71,7 +71,7 @@
  *
  * 'warning: suggest parentheses around arithmetic in operand of |'
  */
-#if defined(NV_LINUX)
+#if defined(NV_LINUX) || defined(NV_BSD)
 #define DRM_IOCTL_NVIDIA_FENCE_SUPPORTED                         \
     DRM_IO(DRM_COMMAND_BASE + DRM_NVIDIA_FENCE_SUPPORTED)
 #define DRM_IOCTL_NVIDIA_DMABUF_SUPPORTED                        \
-- 
2.42.0

